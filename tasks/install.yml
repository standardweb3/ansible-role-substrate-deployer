---
- name: Substrate Install | Download source
  block:
    - name: Substrate Install | Pull Latest tag
      block:
        - name: Substrate Install | Get repository latest release version
          uri:
            url: "{{ substrate_node_releases }}"
            method: GET
            status_code: 200
          register: latest_version

        - name: Substrate Install | Set fact for release
          set_fact:
            substrate_node_latest_version: "{{ latest_version.json.tag_name }}"
      when:
        - substrate_node_version == 'latest'

    - name: Substrate Install | Binary release download
      block:
        - name: Substrate Install | Download release
          get_url:
            url: "{{ substrate_node_source }}"
            dest: "{{ _substrate_node_bin_path }}"
            owner: "{{ substrate_node_user }}"
            group: "{{ substrate_node_group }}"
            force: true
            mode: a+x
            backup: true
          register: _release_binary_download
          until: _release_binary_download is succeeded
          retries: 5
          delay: 2
      when:
        - '".tar.gz" not in substrate_node_source'

    - name: Substrate Install | Archive release download
      block:
        - name: Substrate Install | Unarchive a file that needs to be downloaded
          ansible.builtin.unarchive:
            src: "{{ substrate_node_source }}"
            dest: /tmp
            remote_src: true
            owner: "{{ substrate_node_user }}"
            group: "{{ substrate_node_group }}"
            list_files: true
          register: _unarchive_output

        - name: Substrate Install | List unarchived files
          debug:
            var: _unarchive_output.files

        - name: Substrate Install | Move unarchived file
          ansible.builtin.copy:
            src: "/tmp/{{ _unarchive_output.files[0] }}"
            dest: "{{ _substrate_node_bin_path }}"
            remote_src: true
            owner: "{{ substrate_node_user }}"
            group: "{{ substrate_node_group }}"
            mode: a+x
            backup: true
          register: _release_archive_download
      when:
        - '".tar.gz" in substrate_node_source'
  when:
    - '"http" in substrate_node_source'

- name: Substrate Install | Push source
  block:
    - name: Substrate Install | Binary release push
      block:
        - name: Copy file with owner and permissions
          ansible.builtin.copy:
            src: "{{ substrate_node_source }}"
            dest: "{{ _substrate_node_bin_path }}"
            owner: "{{ substrate_node_user }}"
            group: "{{ substrate_node_group }}"
            mode: a+x
            force: true
            backup: true
          register: _release_binary_push
      when:
        - '".tar.gz" not in substrate_node_source'

    - name: Substrate Install | Archive release push
      block:
        - name: Substrate Install | Unarchive a file that needs to be downloaded
          ansible.builtin.unarchive:
            src: "{{ substrate_node_source }}"
            dest: /tmp
            remote_src: false
            owner: "{{ substrate_node_user }}"
            group: "{{ substrate_node_group }}"
            list_files: true
          register: _unarchive_output

        - name: Substrate Install | List unarchived files
          debug:
            var: _unarchive_output.files

        - name: Substrate Install | Move unarchived file
          ansible.builtin.copy:
            src: "/tmp{{ _unarchive_output.files[0] }}"
            dest: "{{ _substrate_node_bin_path }}"
            remote_src: true
            owner: "{{ substrate_node_user }}"
            group: "{{ substrate_node_group }}"
            mode: a+x
            backup: true
            force: true
          register: _release_archive_push
      when:
        - '".tar.gz" in substrate_node_source'
  when:
    - '"http" not in substrate_node_source'

- debug:
    var: _release_binary_download

- name: Substrate Install | Set fact
  set_fact:
    _binary_updated: true
    _backup_path: "{{ _release_'item[0]'_'item[1]'.backup_file }}"
  when: "_release_{{ item[0] }}_{{ item[1] }}.changed"
  loop: "{{ ['archive', 'binary'] | product(['download', 'push']) | list }}"

- debug:
    var: _binary_updated

- debug:
    var: _backup_path
